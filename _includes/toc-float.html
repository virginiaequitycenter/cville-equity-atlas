<style>
/* img {
  max-width: 100%;
  height: auto;
}
  .rmd-main {
      margin-right: 250px;
  }

  #toc-title {
    font-family: "Oswald";
    font-size: 1.4em;
    font-weight: 300;
  }
   
  .main-container #TOC {
    position: fixed;
    top: 7.5rem; 
    align-self: start;
    right: 2rem;
    max-width: 250px;
  } */
  
  #TOC ul li.active > a {
    color: #1E2952;
  }
  
  #TOC {
    padding-left: 0;
    padding-top: 0;
  }
  
  #TOC  ul {
    list-style: none;
    margin: 0;
    padding: 0;
    /* border-left: 1.5px solid rgba(141,167,190, 0.5);  */
  }
  
  #TOC li {
    margin-left: 1rem;
  }
  
  #TOC a {
    text-decoration: none;
    display: block;
    padding: .125rem 0;
    color: #0370B7;
    transition: all 50ms ease-in-out; 
  }
  
  #TOC a:hover,
  #TOC a:focus {
    color: #1E2952;
  }
  </style>

<!-- <script>/* ========================================================================
  * Bootstrap: transition.js v3.4.1
  * https://getbootstrap.com/docs/3.4/javascript/#transitions
  * ========================================================================
  * Copyright 2011-2019 Twitter, Inc.
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/v3-dev/LICENSE)
  * ======================================================================== */
 
 
 +function ($) {
   'use strict';
 
   // CSS TRANSITION SUPPORT (Shoutout: https://modernizr.com/)
   // ============================================================
 
   function transitionEnd() {
     var el = document.createElement('bootstrap')
 
     var transEndEventNames = {
       WebkitTransition : 'webkitTransitionEnd',
       MozTransition    : 'transitionend',
       OTransition      : 'oTransitionEnd otransitionend',
       transition       : 'transitionend'
     }
 
     for (var name in transEndEventNames) {
       if (el.style[name] !== undefined) {
         return { end: transEndEventNames[name] }
       }
     }
 
     return false // explicit for ie8 (  ._.)
   }
 
   // https://blog.alexmaccaw.com/css-transitions
   $.fn.emulateTransitionEnd = function (duration) {
     var called = false
     var $el = this
     $(this).one('bsTransitionEnd', function () { called = true })
     var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
     setTimeout(callback, duration)
     return this
   }
 
   $(function () {
     $.support.transition = transitionEnd()
 
     if (!$.support.transition) return
 
     $.event.special.bsTransitionEnd = {
       bindType: $.support.transition.end,
       delegateType: $.support.transition.end,
       handle: function (e) {
         if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
       }
     }
   })
 
 }(jQuery);
 </script>
 <script>/* ========================================================================
  * Bootstrap: tab.js v3.4.1
  * https://getbootstrap.com/docs/3.4/javascript/#tabs
  * ========================================================================
  * Copyright 2011-2019 Twitter, Inc.
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  * ======================================================================== */
 
 // Register tab plugin after DOM content loaded in order to
 // override BS5's plugin
 // https://github.com/twbs/bootstrap/blob/08139c22/js/dist/tab.js#L87
 $(function() {
   'use strict';
 
   // TAB CLASS DEFINITION
   // ====================
 
   var Tab = function (element) {
     // jscs:disable requireDollarBeforejQueryAssignment
     this.element = $(element)
     // jscs:enable requireDollarBeforejQueryAssignment
   }
 
   Tab.VERSION = '3.4.1'
 
   Tab.TRANSITION_DURATION = 150
 
   Tab.prototype.show = function () {
     var $this    = this.element
     var $ul      = $this.closest('ul:not(.dropdown-menu)')
     var selector = $this.data('target')
 
     if (!selector) {
       selector = $this.attr('href')
       selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
     }
 
     if ($this.parent('li').hasClass('active')) return
 
     var $previous = $ul.find('.active:last a')
     var hideEvent = $.Event('hide.bs.tab', {
       relatedTarget: $this[0]
     })
     var showEvent = $.Event('show.bs.tab', {
       relatedTarget: $previous[0]
     })
 
     $previous.trigger(hideEvent)
     $this.trigger(showEvent)
 
     if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return
 
     var $target = $(document).find(selector)
 
     this.activate($this.closest('li'), $ul)
     this.activate($target, $target.parent(), function () {
       $previous.trigger({
         type: 'hidden.bs.tab',
         relatedTarget: $this[0]
       })
       $this.trigger({
         type: 'shown.bs.tab',
         relatedTarget: $previous[0]
       })
     })
   }
 
   Tab.prototype.activate = function (element, container, callback) {
     var $active    = container.find('> .active')
     var transition = callback
       && $.support.transition
       && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)
 
     function next() {
       $active
         .removeClass('active')
         .find('> .dropdown-menu > .active')
         .removeClass('active')
         .end()
         .find('[data-toggle="tab"]')
         .attr('aria-expanded', false)
 
       element
         .addClass('active')
         .find('[data-toggle="tab"]')
         .attr('aria-expanded', true)
 
       if (transition) {
         element[0].offsetWidth // reflow for transition
         element.addClass('in')
       } else {
         element.removeClass('fade')
       }
 
       if (element.parent('.dropdown-menu').length) {
         element
           .closest('li.dropdown')
           .addClass('active')
           .end()
           .find('[data-toggle="tab"]')
           .attr('aria-expanded', true)
       }
 
       callback && callback()
     }
 
     $active.length && transition ?
       $active
         .one('bsTransitionEnd', next)
         .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
       next()
 
     $active.removeClass('in')
   }
 
 
   // TAB PLUGIN DEFINITION
   // =====================
 
   function Plugin(option) {
     return this.each(function () {
       var $this = $(this)
       var data  = $this.data('bs.tab')
 
       if (!data) $this.data('bs.tab', (data = new Tab(this)))
       if (typeof option == 'string') data[option]()
     })
   }
 
   var old = $.fn.tab
 
   $.fn.tab             = Plugin
   $.fn.tab.Constructor = Tab
 
 
   // TAB NO CONFLICT
   // ===============
 
   $.fn.tab.noConflict = function () {
     $.fn.tab = old
     return this
   }
 
 
   // TAB DATA-API
   // ============
 
   var clickHandler = function (e) {
     e.preventDefault()
     Plugin.call($(this), 'show')
   }
 
   $(document)
     .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
     .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)
 
 });
 </script>
 <script>// Inform the world that we have the ability to use BS3 nav/navbar markup in BS4
  window.BS3_COMPAT = true;
  
  // This logic needs to execute after both the BS4+ (new) as well as BS3 (legacy)
  // jQuery plugins have been registered. For BS5, plugin registration happens
  // after DOM content is loaded, which is why we do the same here.
  // https://github.com/twbs/bootstrap/blob/08139c22/js/dist/tab.js#L87
  $(function() {
  
    // The legacy plugin needs to be registered after the new one
    if (!$.fn.tab.Constructor.VERSION.match(/^3\./)) {
      (console.warn || console.error || console.log)("bs3compat.js couldn't find bs3 tab impl; bs3 tabs will not be properly supported");
      return;
    }
    var legacyTabPlugin = $.fn.tab.noConflict();
  
    if (!$.fn.tab || !$.fn.tab.Constructor || !$.fn.tab.noConflict) {
      (console.warn || console.error || console.log)("bs3compat.js couldn't find a jQuery tab impl; bs3 tabs will not be properly supported");
    }
    var newTabPlugin = $.fn.tab.noConflict();
  
    // Re-define the tab click event
    // https://github.com/twbs/bootstrap/blob/08139c2/js/src/tab.js#L33
    var EVENT_KEY = "click.bs.tab.data-api";
    $(document).off(EVENT_KEY);
  
    var SELECTOR = '[data-toggle="tab"], [data-toggle="pill"], [data-bs-toggle="tab"], [data-bs-toggle="pill"]';
    $(document).on(EVENT_KEY, SELECTOR, function(event) {
      event.preventDefault();
      $(this).tab("show");
    });
  
    function TabPlugin(config) {
      // Legacy (bs3) tabs: li.active > a
      // New (bs4+) tabs: li.nav-item > a.active.nav-link
      var legacy = $(this).closest(".nav").find("li:not(.dropdown).active > a").length > 0;
      var plugin = legacy ? legacyTabPlugin : newTabPlugin;
      plugin.call($(this), config);
    }
  
    var noconflict = $.fn.tab;
    $.fn.tab = TabPlugin;
    $.fn.tab.Constructor = newTabPlugin.Constructor;
    $.fn.tab.noConflict = function() {
      $.fn.tab = noconflict;
      return TabPlugin;
    };
  });
  </script>

<style type="text/css">

  .tocify {
  width: 20%;
  max-height: 90%;
  overflow: auto;
  margin-left: 2%;
  position: fixed;
  border: 1px solid #ccc;
  border-radius: 6px;
  }
  
  .tocify ul, .tocify li {
  list-style: none;
  margin: 0;
  padding: 0;
  border: none;
  line-height: 30px;
  }
  
  .tocify-header {
  text-indent: 10px;
  }
  
  .tocify-subheader {
  text-indent: 20px;
  display: none;
  }
  
  .tocify-subheader li {
  font-size: 12px;
  }
  
  .tocify-subheader .tocify-subheader {
  text-indent: 30px;
  }
  .tocify-subheader .tocify-subheader .tocify-subheader {
  text-indent: 40px;
  }
  .tocify-subheader .tocify-subheader .tocify-subheader .tocify-subheader {
  text-indent: 50px;
  }
  .tocify-subheader .tocify-subheader .tocify-subheader .tocify-subheader .tocify-subheader {
  text-indent: 60px;
  }
  
  .tocify .tocify-item > a, .tocify .nav-list .nav-header {
  margin: 0px;
  }
  
  .tocify .tocify-item a, .tocify .list-group-item {
  padding: 5px;
  }
  .tocify .nav-pills > li {
  float: none;
  }
  
  
  </style>
  <script>/* jquery Tocify - v1.9.1 - 2013-10-22
   * http://www.gregfranko.com/jquery.tocify.js/
   * Copyright (c) 2013 Greg Franko; Licensed MIT */
  
  // Immediately-Invoked Function Expression (IIFE) [Ben Alman Blog Post](http://benalman.com/news/2010/11/immediately-invoked-function-expression/) that calls another IIFE that contains all of the plugin logic.  I used this pattern so that anyone viewing this code would not have to scroll to the bottom of the page to view the local parameters that were passed to the main IIFE.
  (function(tocify) {
  
      // ECMAScript 5 Strict Mode: [John Resig Blog Post](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/)
      "use strict";
  
      // Calls the second IIFE and locally passes in the global jQuery, window, and document objects
      tocify(window.jQuery, window, document);
  
    }
  
    // Locally passes in `jQuery`, the `window` object, the `document` object, and an `undefined` variable.  The `jQuery`, `window` and `document` objects are passed in locally, to improve performance, since javascript first searches for a variable match within the local variables set before searching the global variables set.  All of the global variables are also passed in locally to be minifier friendly. `undefined` can be passed in locally, because it is not a reserved word in JavaScript.
    (function($, window, document, undefined) {
  
      // ECMAScript 5 Strict Mode: [John Resig Blog Post](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/)
      "use strict";
  
      var tocClassName = "tocify",
        tocClass = "." + tocClassName,
        tocFocusClassName = "tocify-focus",
        tocHoverClassName = "tocify-hover",
        hideTocClassName = "tocify-hide",
        hideTocClass = "." + hideTocClassName,
        headerClassName = "tocify-header",
        headerClass = "." + headerClassName,
        subheaderClassName = "tocify-subheader",
        subheaderClass = "." + subheaderClassName,
        itemClassName = "tocify-item",
        itemClass = "." + itemClassName,
        extendPageClassName = "tocify-extend-page",
        extendPageClass = "." + extendPageClassName;
  
      // Calling the jQueryUI Widget Factory Method
      $.widget("toc.tocify", {
  
        //Plugin version
        version: "1.9.1",
  
        // These options will be used as defaults
        options: {
  
          // **context**: Accepts String: Any jQuery selector
          // The container element that holds all of the elements used to generate the table of contents
          context: "body",
  
          // **ignoreSelector**: Accepts String: Any jQuery selector
          // A selector to any element that would be matched by selectors that you wish to be ignored
          ignoreSelector: null,
  
          // **selectors**: Accepts an Array of Strings: Any jQuery selectors
          // The element's used to generate the table of contents.  The order is very important since it will determine the table of content's nesting structure
          selectors: "h1, h2, h3",
  
          // **showAndHide**: Accepts a boolean: true or false
          // Used to determine if elements should be shown and hidden
          showAndHide: true,
  
          // **showEffect**: Accepts String: "none", "fadeIn", "show", or "slideDown"
          // Used to display any of the table of contents nested items
          showEffect: "slideDown",
  
          // **showEffectSpeed**: Accepts Number (milliseconds) or String: "slow", "medium", or "fast"
          // The time duration of the show animation
          showEffectSpeed: "medium",
  
          // **hideEffect**: Accepts String: "none", "fadeOut", "hide", or "slideUp"
          // Used to hide any of the table of contents nested items
          hideEffect: "slideUp",
  
          // **hideEffectSpeed**: Accepts Number (milliseconds) or String: "slow", "medium", or "fast"
          // The time duration of the hide animation
          hideEffectSpeed: "medium",
  
          // **smoothScroll**: Accepts a boolean: true or false
          // Determines if a jQuery animation should be used to scroll to specific table of contents items on the page
          smoothScroll: true,
  
          // **smoothScrollSpeed**: Accepts Number (milliseconds) or String: "slow", "medium", or "fast"
          // The time duration of the smoothScroll animation
          smoothScrollSpeed: "medium",
  
          // **scrollTo**: Accepts Number (pixels)
          // The amount of space between the top of page and the selected table of contents item after the page has been scrolled
          scrollTo: 0,
  
          // **showAndHideOnScroll**: Accepts a boolean: true or false
          // Determines if table of contents nested items should be shown and hidden while scrolling
          showAndHideOnScroll: true,
  
          // **highlightOnScroll**: Accepts a boolean: true or false
          // Determines if table of contents nested items should be highlighted (set to a different color) while scrolling
          highlightOnScroll: true,
  
          // **highlightOffset**: Accepts a number
          // The offset distance in pixels to trigger the next active table of contents item
          highlightOffset: 40,
  
          // **theme**: Accepts a string: "bootstrap", "jqueryui", or "none"
          // Determines if Twitter Bootstrap, jQueryUI, or Tocify classes should be added to the table of contents
          theme: "bootstrap",
  
          // **extendPage**: Accepts a boolean: true or false
          // If a user scrolls to the bottom of the page and the page is not tall enough to scroll to the last table of contents item, then the page height is increased
          extendPage: true,
  
          // **extendPageOffset**: Accepts a number: pixels
          // How close to the bottom of the page a user must scroll before the page is extended
          extendPageOffset: 100,
  
          // **history**: Accepts a boolean: true or false
          // Adds a hash to the page url to maintain history
          history: true,
  
          // **scrollHistory**: Accepts a boolean: true or false
          // Adds a hash to the page url, to maintain history, when scrolling to a TOC item
          scrollHistory: false,
  
          // **hashGenerator**: How the hash value (the anchor segment of the URL, following the
          // # character) will be generated.
          //
          // "compact" (default) - #CompressesEverythingTogether
          // "pretty" - #looks-like-a-nice-url-and-is-easily-readable
          // function(text, element){} - Your own hash generation function that accepts the text as an
          // argument, and returns the hash value.
          hashGenerator: "compact",
  
          // **highlightDefault**: Accepts a boolean: true or false
          // Set's the first TOC item as active if no other TOC item is active.
          highlightDefault: true
  
        },
  
        // _Create
        // -------
        //      Constructs the plugin.  Only called once.
        _create: function() {
  
          var self = this;
  
          self.extendPageScroll = true;
  
          // Internal array that keeps track of all TOC items (Helps to recognize if there are duplicate TOC item strings)
          self.items = [];
  
          // Generates the HTML for the dynamic table of contents
          self._generateToc();
  
          // Adds CSS classes to the newly generated table of contents HTML
          self._addCSSClasses();
  
          self.webkit = (function() {
  
            for (var prop in window) {
  
              if (prop) {
  
                if (prop.toLowerCase().indexOf("webkit") !== -1) {
  
                  return true;
  
                }
  
              }
  
            }
  
            return false;
  
          }());
  
          // Adds jQuery event handlers to the newly generated table of contents
          self._setEventHandlers();
  
          // Binding to the Window load event to make sure the correct scrollTop is calculated
          $(window).on("load", function() {
  
            // Sets the active TOC item
            self._setActiveElement(true);
  
            // Once all animations on the page are complete, this callback function will be called
            $("html, body").promise().done(function() {
  
              setTimeout(function() {
  
                self.extendPageScroll = false;
  
              }, 0);
  
            });
  
          });
  
        },
  
        // _generateToc
        // ------------
        //      Generates the HTML for the dynamic table of contents
        _generateToc: function() {
  
          // _Local variables_
  
          // Stores the plugin context in the self variable
          var self = this,
  
            // All of the HTML tags found within the context provided (i.e. body) that match the top level jQuery selector above
            firstElem,
  
            // Instantiated variable that will store the top level newly created unordered list DOM element
            ul,
            ignoreSelector = self.options.ignoreSelector;
  
  
          // Determine the element to start the toc with
          // get all the top level selectors
          firstElem = [];
          var selectors = this.options.selectors.replace(/ /g, "").split(",");
          // find the first set that have at least one non-ignored element
          for(var i = 0; i < selectors.length; i++) {
            var foundSelectors = $(this.options.context).find(selectors[i]);
            for (var s = 0; s < foundSelectors.length; s++) {
              if (!$(foundSelectors[s]).is(ignoreSelector)) {
                firstElem = foundSelectors;
                break;
              }
            }
            if (firstElem.length> 0)
              break;
          }
  
          if (!firstElem.length) {
  
            self.element.addClass(hideTocClassName);
  
            return;
  
          }
  
          self.element.addClass(tocClassName);
  
          // Loops through each top level selector
          firstElem.each(function(index) {
  
            //If the element matches the ignoreSelector then we skip it
            if ($(this).is(ignoreSelector)) {
              return;
            }
  
            // Creates an unordered list HTML element and adds a dynamic ID and standard class name
            ul = $("<ul/>", {
              "id": headerClassName + index,
              "class": headerClassName
            }).
  
            // Appends a top level list item HTML element to the previously created HTML header
            append(self._nestElements($(this), index));
  
            // Add the created unordered list element to the HTML element calling the plugin
            self.element.append(ul);
  
            // Finds all of the HTML tags between the header and subheader elements
            $(this).nextUntil(this.nodeName.toLowerCase()).each(function() {
  
              // If there are no nested subheader elemements
              if ($(this).find(self.options.selectors).length === 0) {
  
                // Loops through all of the subheader elements
                $(this).filter(self.options.selectors).each(function() {
  
                  //If the element matches the ignoreSelector then we skip it
                  if ($(this).is(ignoreSelector)) {
                    return;
                  }
  
                  self._appendSubheaders.call(this, self, ul);
  
                });
  
              }
  
              // If there are nested subheader elements
              else {
  
                // Loops through all of the subheader elements
                $(this).find(self.options.selectors).each(function() {
  
                  //If the element matches the ignoreSelector then we skip it
                  if ($(this).is(ignoreSelector)) {
                    return;
                  }
  
                  self._appendSubheaders.call(this, self, ul);
  
                });
  
              }
  
            });
  
          });
  
        },
  
        _setActiveElement: function(pageload) {
  
          var self = this,
  
            hash = window.location.hash.substring(1),
  
            elem = self.element.find('li[data-unique="' + hash + '"]');
  
          if (hash.length) {
  
            // Removes highlighting from all of the list item's
            self.element.find("." + self.focusClass).removeClass(self.focusClass);
  
            // Highlights the current list item that was clicked
            elem.addClass(self.focusClass);
  
            // Triggers the click event on the currently focused TOC item
            elem.click();
  
          } else {
  
            // Removes highlighting from all of the list item's
            self.element.find("." + self.focusClass).removeClass(self.focusClass);
  
            if (!hash.length && pageload && self.options.highlightDefault) {
  
              // Highlights the first TOC item if no other items are highlighted
              self.element.find(itemClass).first().addClass(self.focusClass);
  
            }
  
          }
  
          return self;
  
        },
  
        // _nestElements
        // -------------
        //      Helps create the table of contents list by appending nested list items
        _nestElements: function(self, index) {
  
          var arr, item, hashValue;
  
          arr = $.grep(this.items, function(item) {
  
            return item === self.text();
  
          });
  
          // If there is already a duplicate TOC item
          if (arr.length) {
  
            // Adds the current TOC item text and index (for slight randomization) to the internal array
            this.items.push(self.text() + index);
  
          }
  
          // If there not a duplicate TOC item
          else {
  
            // Adds the current TOC item text to the internal array
            this.items.push(self.text());
  
          }
  
          hashValue = this._generateHashValue(arr, self, index);
  
          // Appends a list item HTML element to the last unordered list HTML element found within the HTML element calling the plugin
          item = $("<li/>", {
  
            // Sets a common class name to the list item
            "class": itemClassName,
  
            "data-unique": hashValue
  
          });
  
          if (this.options.theme !== "bootstrap3") {
  
            item.append($("<a/>", {
  
              "html": self.html()
  
            }));
  
          } else {
  
            item.html(self.html());
  
          }
  
          // Adds an HTML anchor tag before the currently traversed HTML element
          self.before($("<div/>", {
  
            // Sets a name attribute on the anchor tag to the text of the currently traversed HTML element (also making sure that all whitespace is replaced with an underscore)
            "name": hashValue,
  
            "data-unique": hashValue
  
          }));
  
          return item;
  
        },
  
        // _generateHashValue
        // ------------------
        //      Generates the hash value that will be used to refer to each item.
        _generateHashValue: function(arr, self, index) {
  
          var hashValue = "",
            hashGeneratorOption = this.options.hashGenerator;
  
          if (hashGeneratorOption === "pretty") {
  
            // prettify the text
            hashValue = self.text().toLowerCase().replace(/\s/g, "-");
  
            // fix double hyphens
            while (hashValue.indexOf("--") > -1) {
              hashValue = hashValue.replace(/--/g, "-");
            }
  
            // fix colon-space instances
            while (hashValue.indexOf(":-") > -1) {
              hashValue = hashValue.replace(/:-/g, "-");
            }
  
          } else if (typeof hashGeneratorOption === "function") {
  
            // call the function
            hashValue = hashGeneratorOption(self.text(), self);
  
          } else {
  
            // compact - the default
            hashValue = self.text().replace(/\s/g, "");
  
          }
  
          // add the index if we need to
          if (arr.length) {
            hashValue += "" + index;
          }
  
          // return the value
          return hashValue;
  
        },
  
        // _appendElements
        // ---------------
        //      Helps create the table of contents list by appending subheader elements
  
        _appendSubheaders: function(self, ul) {
  
          // The current element index
          var index = $(this).index(self.options.selectors),
  
            // Finds the previous header DOM element
            previousHeader = $(self.options.selectors).eq(index - 1),
  
            currentTagName = +$(this).prop("tagName").charAt(1),
  
            previousTagName = +previousHeader.prop("tagName").charAt(1),
  
            lastSubheader;
  
          // If the current header DOM element is smaller than the previous header DOM element or the first subheader
          if (currentTagName < previousTagName) {
  
            // Selects the last unordered list HTML found within the HTML element calling the plugin
            self.element.find(subheaderClass + "[data-tag=" + currentTagName + "]").last().append(self._nestElements($(this), index));
  
          }
  
          // If the current header DOM element is the same type of header(eg. h4) as the previous header DOM element
          else if (currentTagName === previousTagName) {
  
            ul.find(itemClass).last().after(self._nestElements($(this), index));
  
          } else {
  
            // Selects the last unordered list HTML found within the HTML element calling the plugin
            ul.find(itemClass).last().
  
            // Appends an unorderedList HTML element to the dynamic `unorderedList` variable and sets a common class name
            after($("<ul/>", {
  
              "class": subheaderClassName,
  
              "data-tag": currentTagName
  
            })).next(subheaderClass).
  
            // Appends a list item HTML element to the last unordered list HTML element found within the HTML element calling the plugin
            append(self._nestElements($(this), index));
          }
  
        },
  
        // _setEventHandlers
        // ----------------
        //      Adds jQuery event handlers to the newly generated table of contents
        _setEventHandlers: function() {
  
          // _Local variables_
  
          // Stores the plugin context in the self variable
          var self = this,
  
            // Instantiates a new variable that will be used to hold a specific element's context
            $self,
  
            // Instantiates a new variable that will be used to determine the smoothScroll animation time duration
            duration;
  
          // Event delegation that looks for any clicks on list item elements inside of the HTML element calling the plugin
          this.element.on("click.tocify", "li", function(event) {
  
            if (self.options.history) {
  
              window.location.hash = $(this).attr("data-unique");
  
            }
  
            // Removes highlighting from all of the list item's
            self.element.find("." + self.focusClass).removeClass(self.focusClass);
  
            // Highlights the current list item that was clicked
            $(this).addClass(self.focusClass);
  
            // If the showAndHide option is true
            if (self.options.showAndHide) {
  
              var elem = $('li[data-unique="' + $(this).attr("data-unique") + '"]');
  
              self._triggerShow(elem);
  
            }
  
            self._scrollTo($(this));
  
          });
  
          // Mouseenter and Mouseleave event handlers for the list item's within the HTML element calling the plugin
          this.element.find("li").on({
  
            // Mouseenter event handler
            "mouseenter.tocify": function() {
  
              // Adds a hover CSS class to the current list item
              $(this).addClass(self.hoverClass);
  
              // Makes sure the cursor is set to the pointer icon
              $(this).css("cursor", "pointer");
  
            },
  
            // Mouseleave event handler
            "mouseleave.tocify": function() {
  
              if (self.options.theme !== "bootstrap") {
  
                // Removes the hover CSS class from the current list item
                $(this).removeClass(self.hoverClass);
  
              }
  
            }
          });
  
          // only attach handler if needed (expensive in IE)
          if (self.options.extendPage || self.options.highlightOnScroll || self.options.scrollHistory || self.options.showAndHideOnScroll) {
            // Window scroll event handler
            $(window).on("scroll.tocify", function() {
  
              // Once all animations on the page are complete, this callback function will be called
              $("html, body").promise().done(function() {
  
                // Local variables
  
                // Stores how far the user has scrolled
                var winScrollTop = $(window).scrollTop(),
  
                  // Stores the height of the window
                  winHeight = $(window).height(),
  
                  // Stores the height of the document
                  docHeight = $(document).height(),
  
                  scrollHeight = $("body")[0].scrollHeight,
  
                  // Instantiates a variable that will be used to hold a selected HTML element
                  elem,
  
                  lastElem,
  
                  lastElemOffset,
  
                  currentElem;
  
                if (self.options.extendPage) {
  
                  // If the user has scrolled to the bottom of the page and the last toc item is not focused
                  if ((self.webkit && winScrollTop >= scrollHeight - winHeight - self.options.extendPageOffset) || (!self.webkit && winHeight + winScrollTop > docHeight - self.options.extendPageOffset)) {
  
                    if (!$(extendPageClass).length) {
  
                      lastElem = $('div[data-unique="' + $(itemClass).last().attr("data-unique") + '"]');
  
                      if (!lastElem.length) return;
  
                      // Gets the top offset of the page header that is linked to the last toc item
                      lastElemOffset = lastElem.offset().top;
  
                      // Appends a div to the bottom of the page and sets the height to the difference of the window scrollTop and the last element's position top offset
                      $(self.options.context).append($("<div/>", {
  
                        "class": extendPageClassName,
  
                        "height": Math.abs(lastElemOffset - winScrollTop) + "px",
  
                        "data-unique": extendPageClassName
  
                      }));
  
                      if (self.extendPageScroll) {
  
                        currentElem = self.element.find('li.' + self.focusClass);
  
                        self._scrollTo($('div[data-unique="' + currentElem.attr("data-unique") + '"]'));
  
                      }
  
                    }
  
                  }
  
                }
  
                // The zero timeout ensures the following code is run after the scroll events
                setTimeout(function() {
  
                  // _Local variables_
  
                  // Stores the distance to the closest anchor
                  var closestAnchorDistance = null,
  
                    // Stores the index of the closest anchor
                    closestAnchorIdx = null,
  
                    // Keeps a reference to all anchors
                    anchors = $(self.options.context).find("div[data-unique]"),
  
                    anchorText;
  
                  // Determines the index of the closest anchor
                  anchors.each(function(idx) {
                    var distance = Math.abs(($(this).next().length ? $(this).next() : $(this)).offset().top - winScrollTop - self.options.highlightOffset);
                    if (closestAnchorDistance == null || distance < closestAnchorDistance) {
                      closestAnchorDistance = distance;
                      closestAnchorIdx = idx;
                    } else {
                      return false;
                    }
                  });
  
                  anchorText = $(anchors[closestAnchorIdx]).attr("data-unique");
  
                  // Stores the list item HTML element that corresponds to the currently traversed anchor tag
                  elem = $('li[data-unique="' + anchorText + '"]');
  
                  // If the `highlightOnScroll` option is true and a next element is found
                  if (self.options.highlightOnScroll && elem.length) {
  
                    // Removes highlighting from all of the list item's
                    self.element.find("." + self.focusClass).removeClass(self.focusClass);
  
                    // Highlights the corresponding list item
                    elem.addClass(self.focusClass);
  
                  }
  
                  if (self.options.scrollHistory) {
  
                    if (window.location.hash !== "#" + anchorText) {
  
                      window.location.replace("#" + anchorText);
  
                    }
                  }
  
                  // If the `showAndHideOnScroll` option is true
                  if (self.options.showAndHideOnScroll && self.options.showAndHide) {
  
                    self._triggerShow(elem, true);
  
                  }
  
                }, 0);
  
              });
  
            });
          }
  
        },
  
        // Show
        // ----
        //      Opens the current sub-header
        show: function(elem, scroll) {
  
          // Stores the plugin context in the `self` variable
          var self = this,
            element = elem;
  
          // If the sub-header is not already visible
          if (!elem.is(":visible")) {
  
            // If the current element does not have any nested subheaders, is not a header, and its parent is not visible
            if (!elem.find(subheaderClass).length && !elem.parent().is(headerClass) && !elem.parent().is(":visible")) {
  
              // Sets the current element to all of the subheaders within the current header
              elem = elem.parents(subheaderClass).add(elem);
  
            }
  
            // If the current element does not have any nested subheaders and is not a header
            else if (!elem.children(subheaderClass).length && !elem.parent().is(headerClass)) {
  
              // Sets the current element to the closest subheader
              elem = elem.closest(subheaderClass);
  
            }
  
            //Determines what jQuery effect to use
            switch (self.options.showEffect) {
  
              //Uses `no effect`
              case "none":
  
                elem.show();
  
                break;
  
                //Uses the jQuery `show` special effect
              case "show":
  
                elem.show(self.options.showEffectSpeed);
  
                break;
  
                //Uses the jQuery `slideDown` special effect
              case "slideDown":
  
                elem.slideDown(self.options.showEffectSpeed);
  
                break;
  
                //Uses the jQuery `fadeIn` special effect
              case "fadeIn":
  
                elem.fadeIn(self.options.showEffectSpeed);
  
                break;
  
                //If none of the above options were passed, then a `jQueryUI show effect` is expected
              default:
  
                elem.show();
  
                break;
  
            }
  
          }
  
          // If the current subheader parent element is a header
          if (elem.parent().is(headerClass)) {
  
            // Hides all non-active sub-headers
            self.hide($(subheaderClass).not(elem));
  
          }
  
          // If the current subheader parent element is not a header
          else {
  
            // Hides all non-active sub-headers
            self.hide($(subheaderClass).not(elem.closest(headerClass).find(subheaderClass).not(elem.siblings())));
  
          }
  
          // Maintains chainablity
          return self;
  
        },
  
        // Hide
        // ----
        //      Closes the current sub-header
        hide: function(elem) {
  
          // Stores the plugin context in the `self` variable
          var self = this;
  
          //Determines what jQuery effect to use
          switch (self.options.hideEffect) {
  
            // Uses `no effect`
            case "none":
  
              elem.hide();
  
              break;
  
              // Uses the jQuery `hide` special effect
            case "hide":
  
              elem.hide(self.options.hideEffectSpeed);
  
              break;
  
              // Uses the jQuery `slideUp` special effect
            case "slideUp":
  
              elem.slideUp(self.options.hideEffectSpeed);
  
              break;
  
              // Uses the jQuery `fadeOut` special effect
            case "fadeOut":
  
              elem.fadeOut(self.options.hideEffectSpeed);
  
              break;
  
              // If none of the above options were passed, then a `jqueryUI hide effect` is expected
            default:
  
              elem.hide();
  
              break;
  
          }
  
          // Maintains chainablity
          return self;
        },
  
        // _triggerShow
        // ------------
        //      Determines what elements get shown on scroll and click
        _triggerShow: function(elem, scroll) {
  
          var self = this;
  
          // If the current element's parent is a header element or the next element is a nested subheader element
          if (elem.parent().is(headerClass) || elem.next().is(subheaderClass)) {
  
            // Shows the next sub-header element
            self.show(elem.next(subheaderClass), scroll);
  
          }
  
          // If the current element's parent is a subheader element
          else if (elem.parent().is(subheaderClass)) {
  
            // Shows the parent sub-header element
            self.show(elem.parent(), scroll);
  
          }
  
          // Maintains chainability
          return self;
  
        },
  
        // _addCSSClasses
        // --------------
        //      Adds CSS classes to the newly generated table of contents HTML
        _addCSSClasses: function() {
  
          // If the user wants a jqueryUI theme
          if (this.options.theme === "jqueryui") {
  
            this.focusClass = "ui-state-default";
  
            this.hoverClass = "ui-state-hover";
  
            //Adds the default styling to the dropdown list
            this.element.addClass("ui-widget").find(".toc-title").addClass("ui-widget-header").end().find("li").addClass("ui-widget-content");
  
          }
  
          // If the user wants a twitterBootstrap theme
          else if (this.options.theme === "bootstrap") {
  
            this.element.find(headerClass + "," + subheaderClass).addClass("nav nav-list");
  
            this.focusClass = "active";
  
          }
  
          // If the user wants a twitterBootstrap theme
          else if (this.options.theme === "bootstrap3") {
  
            this.element.find(headerClass + "," + subheaderClass).addClass("list-group");
  
            this.element.find(itemClass).addClass("list-group-item");
  
            this.focusClass = "active";
  
          }
  
          // If a user does not want a prebuilt theme
          else {
  
            // Adds more neutral classes (instead of jqueryui)
  
            this.focusClass = tocFocusClassName;
  
            this.hoverClass = tocHoverClassName;
  
          }
  
          //Maintains chainability
          return this;
  
        },
  
        // setOption
        // ---------
        //      Sets a single Tocify option after the plugin is invoked
        setOption: function() {
  
          // Calls the jQueryUI Widget Factory setOption method
          $.Widget.prototype._setOption.apply(this, arguments);
  
        },
  
        // setOptions
        // ----------
        //      Sets a single or multiple Tocify options after the plugin is invoked
        setOptions: function() {
  
          // Calls the jQueryUI Widget Factory setOptions method
          $.Widget.prototype._setOptions.apply(this, arguments);
  
        },
  
        // _scrollTo
        // ---------
        //      Scrolls to a specific element
        _scrollTo: function(elem) {
  
          var self = this,
            duration = self.options.smoothScroll || 0,
            scrollTo = self.options.scrollTo,
            currentDiv = $('div[data-unique="' + elem.attr("data-unique") + '"]');
  
          if (!currentDiv.length) {
  
            return self;
  
          }
  
          // Once all animations on the page are complete, this callback function will be called
          $("html, body").promise().done(function() {
  
            // Animates the html and body element scrolltops
            $("html, body").animate({
  
              // Sets the jQuery `scrollTop` to the top offset of the HTML div tag that matches the current list item's `data-unique` tag
              "scrollTop": currentDiv.offset().top - ($.isFunction(scrollTo) ? scrollTo.call() : scrollTo) + "px"
  
            }, {
  
              // Sets the smoothScroll animation time duration to the smoothScrollSpeed option
              "duration": duration
  
            });
  
          });
  
          // Maintains chainability
          return self;
  
        }
  
      });
  
    })); //end of plugin
  </script>
  <script>
  
  /**
   * jQuery Plugin: Sticky Tabs
   *
   * @author Aidan Lister <aidan@php.net>
   * adapted by Ruben Arslan to activate parent tabs too
   * http://www.aidanlister.com/2014/03/persisting-the-tab-state-in-bootstrap/
   */
  (function($) {
    "use strict";
    $.fn.rmarkdownStickyTabs = function() {
      var context = this;
      // Show the tab corresponding with the hash in the URL, or the first tab
      var showStuffFromHash = function() {
        var hash = window.location.hash;
        var selector = hash ? 'a[href="' + hash + '"]' : 'li.active > a';
        var $selector = $(selector, context);
        if($selector.data('toggle') === "tab") {
          $selector.tab('show');
          // walk up the ancestors of this element, show any hidden tabs
          $selector.parents('.section.tabset').each(function(i, elm) {
            var link = $('a[href="#' + $(elm).attr('id') + '"]');
            if(link.data('toggle') === "tab") {
              link.tab("show");
            }
          });
        }
      };
  
  
      // Set the correct tab when the page loads
      showStuffFromHash(context);
  
      // Set the correct tab when a user uses their back/forward button
      $(window).on('hashchange', function() {
        showStuffFromHash(context);
      });
  
      // Change the URL when tabs are clicked
      $('a', context).on('click', function(e) {
        history.pushState(null, null, this.href);
        showStuffFromHash(context);
      });
  
      return this;
    };
  }(jQuery));
  
  window.buildTabsets = function(tocID) {
  
    // build a tabset from a section div with the .tabset class
    function buildTabset(tabset) {
  
      // check for fade and pills options
      var fade = tabset.hasClass("tabset-fade");
      var pills = tabset.hasClass("tabset-pills");
      var navClass = pills ? "nav-pills" : "nav-tabs";
  
      // determine the heading level of the tabset and tabs
      var match = tabset.attr('class').match(/level(\d) /);
      if (match === null)
        return;
      var tabsetLevel = Number(match[1]);
      var tabLevel = tabsetLevel + 1;
  
      // find all subheadings immediately below
      var tabs = tabset.find("div.section.level" + tabLevel);
      if (!tabs.length)
        return;
  
      // create tablist and tab-content elements
      var tabList = $('<ul class="nav ' + navClass + '" role="tablist"></ul>');
      $(tabs[0]).before(tabList);
      var tabContent = $('<div class="tab-content"></div>');
      $(tabs[0]).before(tabContent);
  
      // build the tabset
      var activeTab = 0;
      tabs.each(function(i) {
  
        // get the tab div
        var tab = $(tabs[i]);
  
        // get the id then sanitize it for use with bootstrap tabs
        var id = tab.attr('id');
  
        // see if this is marked as the active tab
        if (tab.hasClass('active'))
          activeTab = i;
  
        // remove any table of contents entries associated with
        // this ID (since we'll be removing the heading element)
        $("div#" + tocID + " li a[href='#" + id + "']").parent().remove();
  
        // sanitize the id for use with bootstrap tabs
        id = id.replace(/[.\/?&!#<>]/g, '').replace(/\s/g, '_');
        tab.attr('id', id);
  
        // get the heading element within it, grab it's text, then remove it
        var heading = tab.find('h' + tabLevel + ':first');
        var headingText = heading.html();
        heading.remove();
  
        // build and append the tab list item
        var a = $('<a role="tab" data-toggle="tab">' + headingText + '</a>');
        a.attr('href', '#' + id);
        a.attr('aria-controls', id);
        var li = $('<li role="presentation"></li>');
        li.append(a);
        tabList.append(li);
  
        // set it's attributes
        tab.attr('role', 'tabpanel');
        tab.addClass('tab-pane');
        tab.addClass('tabbed-pane');
        if (fade)
          tab.addClass('fade');
  
        // move it into the tab content div
        tab.detach().appendTo(tabContent);
      });
  
      // set active tab
      $(tabList.children('li')[activeTab]).addClass('active');
      var active = $(tabContent.children('div.section')[activeTab]);
      active.addClass('active');
      if (fade)
        active.addClass('in');
  
      if (tabset.hasClass("tabset-sticky"))
        tabset.rmarkdownStickyTabs();
    }
  
    // convert section divs with the .tabset class to tabsets
    var tabsets = $("div.section.tabset");
    tabsets.each(function(i) {
      buildTabset($(tabsets[i]));
    });
  };
  
  </script>

<style type="text/css">
  #TOC {
  margin: 25px 0px 20px 0px;
  }
  @media (max-width: 768px) {
  #TOC {
  position: relative;
  width: 100%;
  }
  }
  @media print {
  .toc-content {
  
  float: right;
  }
  }
  .toc-content {
  padding-left: 30px;
  padding-right: 40px;
  }
  div.main-container {
  max-width: 1200px;
  }
  div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
  }
  @media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
  width: 25%;
  }
  }
  @media (max-width: 767px) {
  div.tocify {
  width: 100%;
  max-width: none;
  }
  }
  .tocify ul, .tocify li {
  line-height: 20px;
  }
  .tocify-subheader .tocify-item {
  font-size: 0.90em;
  }
  .tocify .list-group-item {
  border-radius: 0px;
  }
  </style> -->